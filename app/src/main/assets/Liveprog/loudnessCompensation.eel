// APO Loudness-like Equal-Loudness Compensation for JamesDSP
// This script implements ISO 226:2003 equal-loudness contours
// 
// Parameters:
// slider1: Listening Level (dB SPL) - Current listening volume
// slider2: Reference Level (dB SPL) - Target reference level  
// slider3: Compensation Amount (%) - How much compensation to apply
// slider4: Auto Mode (0/1) - Automatically detect volume from output gain

desc:Equal-Loudness Compensation

slider1:60<40,90,1>Listening Level (dB SPL)
slider2:83<70,90,1>Reference Level (dB SPL)  
slider3:100<0,100,1>Compensation Amount (%)
slider4:0<0,1,1{Manual,Auto}>Mode

@init
// Frequency points for ISO 226:2003 curves
freqs = 1000;
freqs[0] = 20;    freqs[1] = 25;    freqs[2] = 31.5;  freqs[3] = 40;
freqs[4] = 50;    freqs[5] = 63;    freqs[6] = 80;    freqs[7] = 100;
freqs[8] = 125;   freqs[9] = 160;   freqs[10] = 200;  freqs[11] = 250;
freqs[12] = 315;  freqs[13] = 400;  freqs[14] = 500;  freqs[15] = 630;
freqs[16] = 800;  freqs[17] = 1000; freqs[18] = 1250; freqs[19] = 1600;
freqs[20] = 2000; freqs[21] = 2500; freqs[22] = 3150; freqs[23] = 4000;
freqs[24] = 5000; freqs[25] = 6300; freqs[26] = 8000; freqs[27] = 10000;
freqs[28] = 12500;

num_freqs = 29;

// Threshold of hearing (approximation)
ath = 2000;
ath[0] = 74.3;  ath[1] = 65.0;  ath[2] = 56.3;  ath[3] = 48.4;
ath[4] = 41.7;  ath[5] = 35.5;  ath[6] = 29.8;  ath[7] = 24.4;
ath[8] = 19.3;  ath[9] = 14.6;  ath[10] = 10.1; ath[11] = 6.0;
ath[12] = 2.5;  ath[13] = -0.8; ath[14] = -3.6; ath[15] = -6.2;
ath[16] = -8.5; ath[17] = -10.3;ath[18] = -11.7;ath[19] = -12.6;
ath[20] = -12.8;ath[21] = -12.2;ath[22] = -11.0;ath[23] = -9.0;
ath[24] = -6.5; ath[25] = -3.6; ath[26] = -0.8; ath[27] = 2.4;
ath[28] = 6.8;

// Initialize filters
filter_count = 10; // Number of parametric EQ bands
i = 0;
while(i < filter_count) (
  rbj_init(3000 + i*100); // Initialize filter memory locations
  i += 1;
);

// Calculate equal-loudness contour for a given SPL
function calculate_loudness(spl, freq_idx) (
  local(af, lu, tf);
  
  // Simplified ISO 226:2003 calculation
  af = ath[freq_idx];
  
  // Approximation of loudness level
  tf = af + 4.2 + 0.0031 * (freqs[freq_idx] - 1000);
  lu = -0.6 * (spl - tf) + 94;
  
  lu
);

// Calculate compensation needed between two loudness levels
function calculate_compensation(listen_spl, ref_spl, freq_idx) (
  local(listen_loud, ref_loud, diff);
  
  listen_loud = calculate_loudness(listen_spl, freq_idx);
  ref_loud = calculate_loudness(ref_spl, freq_idx);
  
  diff = ref_loud - listen_loud;
  
  // Convert loudness difference to dB
  diff * 0.3 // Approximation factor
);

// RBJ EQ filter coefficients
function rbj_eq(freq, q, gain_db, mem_offset) (
  local(a, w0, cos_w0, alpha, a0, a1, a2, b0, b1, b2);
  
  a = 10^(gain_db/40);
  w0 = 2 * $pi * freq / srate;
  cos_w0 = cos(w0);
  alpha = sin(w0) / (2 * q);
  
  b0 = 1 + alpha * a;
  b1 = -2 * cos_w0;
  b2 = 1 - alpha * a;
  a0 = 1 + alpha / a;
  a1 = -2 * cos_w0;
  a2 = 1 - alpha / a;
  
  // Normalize
  mem_offset[0] = b0 / a0;
  mem_offset[1] = b1 / a0;
  mem_offset[2] = b2 / a0;
  mem_offset[3] = -a1 / a0;
  mem_offset[4] = -a2 / a0;
);

// Apply RBJ filter
function rbj_process(input, mem_offset) (
  local(output);
  
  output = input * mem_offset[0] + mem_offset[10];
  mem_offset[10] = input * mem_offset[1] + mem_offset[11] - output * mem_offset[3];
  mem_offset[11] = input * mem_offset[2] - output * mem_offset[4];
  
  output
);

// Initialize filter bank
last_listen_spl = -1;
last_ref_spl = -1;

@slider
// Force recalculation when sliders change
last_listen_spl = -1;

@sample
// Update filters if parameters changed
(slider1 != last_listen_spl || slider2 != last_ref_spl) ? (
  last_listen_spl = slider1;
  last_ref_spl = slider2;
  
  // Auto mode: estimate SPL from current gain
  actual_listen_spl = slider4 > 0.5 ? 
    (83 + slider1 - 60) : // Simple mapping, could be improved
    slider1;
  
  // Calculate compensation for key frequency bands
  // Bass: 63 Hz
  comp_63 = calculate_compensation(actual_listen_spl, slider2, 5);
  rbj_eq(63, 0.7, comp_63 * slider3 / 100, 3000);
  
  // Low-mid: 250 Hz  
  comp_250 = calculate_compensation(actual_listen_spl, slider2, 11);
  rbj_eq(250, 0.7, comp_250 * slider3 / 100, 3100);
  
  // Mid: 1 kHz (usually no compensation needed)
  comp_1k = calculate_compensation(actual_listen_spl, slider2, 17);
  rbj_eq(1000, 0.7, comp_1k * slider3 / 100, 3200);
  
  // High-mid: 4 kHz
  comp_4k = calculate_compensation(actual_listen_spl, slider2, 23);
  rbj_eq(4000, 0.7, comp_4k * slider3 / 100, 3300);
  
  // Treble: 10 kHz
  comp_10k = calculate_compensation(actual_listen_spl, slider2, 27);
  rbj_eq(10000, 0.7, comp_10k * slider3 / 100, 3400);
  
  // Additional bands for smoother response
  comp_125 = calculate_compensation(actual_listen_spl, slider2, 8);
  rbj_eq(125, 0.7, comp_125 * slider3 / 100, 3500);
  
  comp_500 = calculate_compensation(actual_listen_spl, slider2, 14);
  rbj_eq(500, 0.7, comp_500 * slider3 / 100, 3600);
  
  comp_2k = calculate_compensation(actual_listen_spl, slider2, 20);
  rbj_eq(2000, 0.7, comp_2k * slider3 / 100, 3700);
  
  comp_8k = calculate_compensation(actual_listen_spl, slider2, 26);
  rbj_eq(8000, 0.7, comp_8k * slider3 / 100, 3800);
);

// Process audio
spl0 = spl0;
spl1 = spl1;

// Apply filter bank (only if compensation is enabled)
slider3 > 0 ? (
  // Process left channel
  spl0 = rbj_process(spl0, 3000);
  spl0 = rbj_process(spl0, 3100);
  spl0 = rbj_process(spl0, 3200);
  spl0 = rbj_process(spl0, 3300);
  spl0 = rbj_process(spl0, 3400);
  spl0 = rbj_process(spl0, 3500);
  spl0 = rbj_process(spl0, 3600);
  spl0 = rbj_process(spl0, 3700);
  spl0 = rbj_process(spl0, 3800);
  
  // Process right channel  
  spl1 = rbj_process(spl1, 3000);
  spl1 = rbj_process(spl1, 3100);
  spl1 = rbj_process(spl1, 3200);
  spl1 = rbj_process(spl1, 3300);
  spl1 = rbj_process(spl1, 3400);
  spl1 = rbj_process(spl1, 3500);
  spl1 = rbj_process(spl1, 3600);
  spl1 = rbj_process(spl1, 3700);
  spl1 = rbj_process(spl1, 3800);
);